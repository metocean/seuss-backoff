// Generated by CoffeeScript 1.9.2
var Queue, async;

Queue = require('seuss-queue');

async = require('odo-async');

module.exports = function(options) {
  var _currentbackoff, _drain, _inprogress, _ondrain, _retry, _retrytimeout, backoff, factor, inflight, limit, notify, onitem, retrying;
  onitem = options.onitem;
  inflight = options.inflight;
  if (inflight == null) {
    inflight = Queue();
  }
  retrying = options.retrying;
  if (retrying == null) {
    retrying = Queue();
  }
  backoff = options.delay;
  if (backoff == null) {
    backoff = 500;
  }
  factor = options.factor;
  if (factor == null) {
    factor = 1.5;
  }
  limit = options.limit;
  if (limit == null) {
    limit = 1000 * 60;
  }
  notify = options.notify;
  if (notify == null) {
    notify = 1000 * 30;
  }
  _retrytimeout = null;
  _inprogress = false;
  _currentbackoff = backoff;
  _ondrain = [];
  _retry = function() {
    var all, i, item, len;
    _currentbackoff *= factor;
    _currentbackoff = Math.max(_currentbackoff, limit);
    all = retrying.all();
    for (i = 0, len = all.length; i < len; i++) {
      item = all[i];
      inflight.enqueue(item);
    }
    retrying = Queue();
    _retrytimeout = null;
    if (!_inprogress) {
      return _drain();
    }
  };
  _drain = function() {
    var cb, i, item, len, ondrain;
    _inprogress = true;
    if (inflight.length() === 0) {
      if (retrying.length() === 0) {
        _currentbackoff = backoff;
        ondrain = _ondrain;
        _ondrain = [];
        for (i = 0, len = ondrain.length; i < len; i++) {
          cb = ondrain[i];
          cb();
        }
      } else if (_retrytimeout === null) {
        if (_currentbackoff >= notify) {
          console.error("Retrying " + (retrying.length()) + " messages in " + (_currentbackoff / 1000) + "s");
        }
        _retrytimeout = setTimeout(_retry, _currentbackoff);
      }
      if (inflight.length() === 0) {
        _inprogress = false;
        return;
      }
    }
    item = inflight.peek();
    return onitem(item, function(success) {
      if (!success) {
        retrying.enqueue(item);
      }
      inflight.dequeue();
      return async.delay(_drain);
    });
  };
  if (!_inprogress) {
    _drain();
  }
  return {
    enqueue: function(item, cb) {
      inflight.enqueue(item);
      if (!_inprogress) {
        return _drain();
      }
    },
    inflight: function() {
      return inflight.all();
    },
    retrying: function() {
      return retrying.all();
    },
    all: function() {
      return [].concat(retrying.all()).concat(inflight.all());
    },
    length: function() {
      return inflight.length() + retrying.length();
    },
    compact: function() {
      inflight.compact();
      return retrying.compact;
    },
    drain: function(cb) {
      if (!_inprogress && _retrytimeout === null) {
        return cb();
      }
      return _ondrain.push(cb);
    },
    destroy: function() {
      if (_retrytimeout) {
        clearTimeout(_retrytimeout);
        return _retrytimeout = null;
      }
    }
  };
};
